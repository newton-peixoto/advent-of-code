# Advent of code day 10

```elixir
Mix.install([
  {:kino, "~> 0.5.0"}
])
```

## Setup input

```elixir
example = Kino.Input.textarea("Please paste your input example:")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input = Kino.Input.textarea("Please paste your real input:")
```

```elixir
stones =
  example
  |> Kino.Input.read()
  |> String.split(" ", trim: true)
  |> Enum.map(&String.to_integer/1)
```

```elixir

# My first approach was to just loop through all recursion size
# it went well for part01
# part02 was very heavy so we need a optmization. First try was memo but after some thinking 
# decided to try a map approach 
defmodule Blinker do
  def blink_times(stones, 0), do: stones

  def blink_times(stones, times) do
    stones
    |> Map.to_list()
    |> blink(%{})
    |> blink_times(times - 1)
  end

  def blink([], acc), do: acc

  def blink([{0, n} | rest], acc) do
    blink(rest, Map.update(acc, 1, n, &(&1 + n)))
  end

  def blink([{x, n} | rest], acc) do
    digits = Integer.digits(x) 

    case rem(Enum.count(digits), 2) do
      0 ->
        {a, b} = Enum.split(digits, div(Enum.count(digits), 2))

        acc =
          acc
          |> Map.update(Integer.undigits(a), n, &(&1 + n))
          |> Map.update(Integer.undigits(b), n, &(&1 + n))

        blink(rest, acc)

      1 ->
        blink(rest, Map.update(acc, x * 2024, n, &(&1 + n)))
    end
  end
end
```

## Part 01

```elixir
stones = stones |> Enum.frequencies

stones |> Blinker.blink_times(25)  |> Map.values |> Enum.sum
```

## Part 02

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
stones |> Blinker.blink_times(75)  |> Map.values |> Enum.sum
```
