# Advent of code day 10

```elixir
Mix.install([
  {:kino, "~> 0.5.0"},
  {:dantzig, "~> 0.1.0"}
])
```

## Setup input

```elixir
example = Kino.Input.textarea("Please paste your input example:")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input = Kino.Input.textarea("Please paste your real input:")
```

```elixir
defmodule Combinations do
  def combinations(_, 0), do: [[]]
  def combinations([], _), do: []
  
  def combinations([h | t], r) do
    (for combo <- combinations(t, r - 1), do: [h | combo]) ++ combinations(t, r)
  end
end
```

## Part 01

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
lines =
  example
  |> Kino.Input.read()
  |> String.split("\n", trim: true)
  |> Enum.map(fn line ->
    [target | rest] = String.split(line, " ", trim: true)
    [j | buttons] = Enum.reverse(rest)
    
    buttons =
      Enum.reverse(buttons)
      |> Enum.map(fn button ->
        button
        |> String.trim_leading("(")
        |> String.trim_trailing(")")
        |> String.split(",")
        |> Enum.map(&String.to_integer/1)
        |> Enum.into(MapSet.new())
      end)
    
    target =
      target
      |> String.trim_leading("[")
      |> String.trim_trailing("]")
      |> String.split("", trim: true)
      |> Enum.with_index()
      |> Enum.filter(fn {v, _i} -> v == "#" end)
      |> Enum.map(fn {_, i} -> i end)
      |> Enum.into(MapSet.new())
    
    {target, buttons, j}
  end)

total =
  Enum.reduce(lines, 0, fn {target, buttons, _}, acc ->
    result = Enum.reduce_while(1..length(buttons), 0, fn count, _inner_acc ->
      found = Enum.reduce_while(Combinations.combinations(buttons, count), nil, fn attempt, _light ->
        lights = Enum.reduce(attempt, MapSet.new(), fn button, lights ->
          MapSet.symmetric_difference(lights, button)
        end)
        
        if MapSet.equal?(lights, target) do
          {:halt, count}
        else
          {:cont, nil}
        end
      end)
      
      if found != nil do
        {:halt, found}
      else
        {:cont, 0}
      end
    end)
    
    acc + result
  end)
```

## Part 02

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule A do
  require Dantzig.Problem, as: Problem
  alias Dantzig.Solution
  require Dantzig.Constraint, as: Constraint
  use Dantzig.Polynomial.Operators

  def a do
    total_width = 300.0
    problem = Problem.new(direction: :maximize)

    fits_inside = fn problem, inside, outside ->
      Problem.add_constraint(problem, Constraint.new(inside <= outside))
    end

    long_calculation_by_external_program = fn _boxes ->
      [15, 40, 38.0]
    end

    problem =
      Problem.with_implicit_problem problem do
        v!(left_margin, min: 0.0)
        v!(center, min: 0.0)
        v!(right_margin, min: 0.0)

        v!(box1_width, min: 0.0)
        v!(box2_width, min: 0.0)
        v!(box3_width, min: 0.0)

        v!(canvas1_width, min: 0.0)
        v!(canvas2_width, min: 0.0)
        v!(canvas3_width, min: 0.0)

        constraint!(canvas1_width + canvas2_width + canvas3_width == center)
        # REMOVE these ratio constraints - they over-constrain the problem
        # constraint!(canvas1_width == 2 * canvas2_width)
        # constraint!(canvas1_width == 2 * canvas3_width)

        problem = fits_inside.(problem, box1_width, canvas1_width)
        problem = fits_inside.(problem, box2_width, canvas2_width)
        problem = fits_inside.(problem, box3_width, canvas3_width)

        [box1_w, box2_w, box3_w] =
          long_calculation_by_external_program.([
            box1_width,
            box2_width,
            box3_width
          ])

        constraint!(box1_width == box1_w)
        constraint!(box2_width == box2_w)
        constraint!(box3_width == box3_w)

        constraint!(left_margin + center + right_margin == total_width)

        increment_objective!(center - left_margin - right_margin)

        problem
      end

    solution = Dantzig.solve(problem)
    # Return the solution
    solution
  end
end

A.a()
```
